//
// TranslationResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct TranslationResponse: Codable, JSONEncodable, Hashable {

    public enum Direction: String, Codable, CaseIterable {
        case englishToGenz = "english_to_genz"
        case genzToEnglish = "genz_to_english"
    }
    public enum FailureReason: String, Codable, CaseIterable {
        case lowConfidence = "low_confidence"
        case noTranslationNeeded = "no_translation_needed"
    }
    public enum Tier: String, Codable, CaseIterable {
        case free = "free"
        case premium = "premium"
    }
    public static let confidenceScoreRule = NumericRule<Double>(minimum: 0, exclusiveMinimum: false, maximum: 1, exclusiveMaximum: false, multipleOf: nil)
    /** Unique translation ID */
    public var translationId: String
    public var originalText: String
    public var translatedText: String
    /** Translation direction used */
    public var direction: Direction
    public var confidenceScore: Double?
    /** Translation timestamp */
    public var createdAt: Date
    /** Processing time in milliseconds */
    public var processingTimeMs: Int?
    /** AI model used for translation */
    public var modelUsed: String?
    /** Whether the translation failed or returned the same text */
    public var translationFailed: Bool
    /** Technical reason for translation failure */
    public var failureReason: FailureReason?
    /** User-friendly message about the translation result */
    public var userMessage: String?
    /** Whether user can submit slang feedback (premium feature, only true when translation fails) */
    public var canSubmitFeedback: Bool?
    /** Total translations used today (after this translation) */
    public var dailyUsed: Int
    /** Daily translation limit */
    public var dailyLimit: Int
    /** User tier (free/premium) */
    public var tier: Tier

    public init(translationId: String, originalText: String, translatedText: String, direction: Direction, confidenceScore: Double? = nil, createdAt: Date, processingTimeMs: Int? = nil, modelUsed: String? = nil, translationFailed: Bool, failureReason: FailureReason? = nil, userMessage: String? = nil, canSubmitFeedback: Bool? = nil, dailyUsed: Int, dailyLimit: Int, tier: Tier) {
        self.translationId = translationId
        self.originalText = originalText
        self.translatedText = translatedText
        self.direction = direction
        self.confidenceScore = confidenceScore
        self.createdAt = createdAt
        self.processingTimeMs = processingTimeMs
        self.modelUsed = modelUsed
        self.translationFailed = translationFailed
        self.failureReason = failureReason
        self.userMessage = userMessage
        self.canSubmitFeedback = canSubmitFeedback
        self.dailyUsed = dailyUsed
        self.dailyLimit = dailyLimit
        self.tier = tier
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case translationId = "translation_id"
        case originalText = "original_text"
        case translatedText = "translated_text"
        case direction
        case confidenceScore = "confidence_score"
        case createdAt = "created_at"
        case processingTimeMs = "processing_time_ms"
        case modelUsed = "model_used"
        case translationFailed = "translation_failed"
        case failureReason = "failure_reason"
        case userMessage = "user_message"
        case canSubmitFeedback = "can_submit_feedback"
        case dailyUsed = "daily_used"
        case dailyLimit = "daily_limit"
        case tier
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(translationId, forKey: .translationId)
        try container.encode(originalText, forKey: .originalText)
        try container.encode(translatedText, forKey: .translatedText)
        try container.encode(direction, forKey: .direction)
        try container.encodeIfPresent(confidenceScore, forKey: .confidenceScore)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(processingTimeMs, forKey: .processingTimeMs)
        try container.encodeIfPresent(modelUsed, forKey: .modelUsed)
        try container.encode(translationFailed, forKey: .translationFailed)
        try container.encodeIfPresent(failureReason, forKey: .failureReason)
        try container.encodeIfPresent(userMessage, forKey: .userMessage)
        try container.encodeIfPresent(canSubmitFeedback, forKey: .canSubmitFeedback)
        try container.encode(dailyUsed, forKey: .dailyUsed)
        try container.encode(dailyLimit, forKey: .dailyLimit)
        try container.encode(tier, forKey: .tier)
    }
}

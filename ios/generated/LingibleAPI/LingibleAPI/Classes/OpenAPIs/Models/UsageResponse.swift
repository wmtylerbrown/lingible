//
// UsageResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct UsageResponse: Codable, JSONEncodable, Hashable {

    public enum Tier: String, Codable, CaseIterable {
        case free = "free"
        case premium = "premium"
    }
    /** User tier */
    public var tier: Tier?
    /** Daily translation limit */
    public var dailyLimit: Int?
    /** Number of translations used today */
    public var dailyUsed: Int?
    /** Number of translations remaining today */
    public var dailyRemaining: Int?
    /** Next daily reset date */
    public var resetDate: Date?
    /** Maximum text length for user's current tier */
    public var currentMaxTextLength: Int?
    /** Free tier text length limit */
    public var freeTierMaxLength: Int?
    /** Premium tier text length limit */
    public var premiumTierMaxLength: Int?
    /** Free tier daily translation limit */
    public var freeDailyLimit: Int?
    /** Premium tier daily translation limit */
    public var premiumDailyLimit: Int?

    public init(tier: Tier? = nil, dailyLimit: Int? = nil, dailyUsed: Int? = nil, dailyRemaining: Int? = nil, resetDate: Date? = nil, currentMaxTextLength: Int? = nil, freeTierMaxLength: Int? = nil, premiumTierMaxLength: Int? = nil, freeDailyLimit: Int? = nil, premiumDailyLimit: Int? = nil) {
        self.tier = tier
        self.dailyLimit = dailyLimit
        self.dailyUsed = dailyUsed
        self.dailyRemaining = dailyRemaining
        self.resetDate = resetDate
        self.currentMaxTextLength = currentMaxTextLength
        self.freeTierMaxLength = freeTierMaxLength
        self.premiumTierMaxLength = premiumTierMaxLength
        self.freeDailyLimit = freeDailyLimit
        self.premiumDailyLimit = premiumDailyLimit
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case tier
        case dailyLimit = "daily_limit"
        case dailyUsed = "daily_used"
        case dailyRemaining = "daily_remaining"
        case resetDate = "reset_date"
        case currentMaxTextLength = "current_max_text_length"
        case freeTierMaxLength = "free_tier_max_length"
        case premiumTierMaxLength = "premium_tier_max_length"
        case freeDailyLimit = "free_daily_limit"
        case premiumDailyLimit = "premium_daily_limit"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(tier, forKey: .tier)
        try container.encodeIfPresent(dailyLimit, forKey: .dailyLimit)
        try container.encodeIfPresent(dailyUsed, forKey: .dailyUsed)
        try container.encodeIfPresent(dailyRemaining, forKey: .dailyRemaining)
        try container.encodeIfPresent(resetDate, forKey: .resetDate)
        try container.encodeIfPresent(currentMaxTextLength, forKey: .currentMaxTextLength)
        try container.encodeIfPresent(freeTierMaxLength, forKey: .freeTierMaxLength)
        try container.encodeIfPresent(premiumTierMaxLength, forKey: .premiumTierMaxLength)
        try container.encodeIfPresent(freeDailyLimit, forKey: .freeDailyLimit)
        try container.encodeIfPresent(premiumDailyLimit, forKey: .premiumDailyLimit)
    }
}

